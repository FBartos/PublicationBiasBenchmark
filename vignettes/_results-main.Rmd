---
title: "results-main"
output: html_document
---

```{r, include = FALSE}
# Local/Remote pathing with nested child paths is extremely buggy. This function makes sure that all paths are properly set
child_path <- function(x) {
  # Try to get the package name safely
  pkg <- tryCatch(utils::packageName(), error = function(e) NULL)
  if (is.null(pkg) || length(pkg) != 1 || is.na(pkg) || !nzchar(pkg)) {
    pkg <- tryCatch(desc::desc_get("Package")[[1]], error = function(e) NA_character_)
  }
  if (is.null(pkg) || is.na(pkg) || !nzchar(pkg)) {
    pkg <- basename(rprojroot::find_package_root_file())
  }

  # First try the installed vignettes dir (works when pkgdown builds from an installed copy)
  p <- tryCatch(system.file("vignettes", x, package = pkg), error = function(e) "")
  if (!is.character(p) || length(p) != 1 || !nzchar(p)) p <- ""

  # Fallback to the source tree
  if (!nzchar(p)) {
    p <- file.path(rprojroot::find_package_root_file(), "vignettes", x)
  }

  normalizePath(p, winslash = "/", mustWork = TRUE)
}

```

```{r, include = FALSE}
# This is a child document meant to be included in other Rmd files
# Exit if being knit directly (not as a child)
if (!exists("dgm_names")) {
  message("This is a helper file that should be included as a child in other Rmd documents.")
  message("It requires 'dgm_names' to be defined in the parent document.")
  knitr::knit_exit()
}
```

```{r, include = FALSE}
# Load and merge the 
# use pre-local results if compiled locally
if (dir.exists("C:/R-Packages/PublicationBiasBenchmark/resources")) {
  path <- "C:/R-Packages/PublicationBiasBenchmark/resources"
} else { 
  path <- NULL
}

library(PublicationBiasBenchmark)
PublicationBiasBenchmark.options('prompt_for_download' = FALSE)
library(ggplot2)
library(ggdist)
library(scales)

results_conditional_list <- list()
results_replacement_list <- list()
for (dgm_name in dgm_names) {
  
  # retrieve all measures across all conditions and measures
  download_dgm_measures(dgm_name, path = path)
  temp_conditional <- retrieve_dgm_measures(dgm_name, path = path)
  temp_replacement <- retrieve_dgm_measures(dgm_name, replacement = TRUE, path = path)  
  
  # retrieve conditions
  conditions <- dgm_conditions(dgm_name)
  
  # add labels
  temp_conditional$label <- with(temp_conditional, paste0(method, " (", method_setting, ")"))
  temp_replacement$label <- with(temp_replacement, paste0(method, " (", method_setting, ")"))
  temp_conditional$dgm_name <- dgm_name
  temp_replacement$dgm_name <- dgm_name
    
  # distinguish between H0 and H1
  temp_conditional$H0 <- temp_conditional$condition_id %in% conditions$condition_id[conditions$mean_effect == 0]
  temp_replacement$H0 <- temp_replacement$condition_id %in% conditions$condition_id[conditions$mean_effect == 0]
  
  if (!common_scale) {
    # add rmse and bias ranks (can be reused by the subsequent computations)
    temp_conditional$bias_rank <- NA
    temp_replacement$bias_rank <- NA
    temp_conditional$rmse_rank <- NA
    temp_replacement$rmse_rank <- NA
    for (condition_id in unique(temp_conditional$condition_id)) {
      temp_conditional$bias_rank[temp_conditional$condition_id == condition_id] <- rank(abs(temp_conditional$bias[temp_conditional$condition_id == condition_id]), ties.method = "min")
      temp_replacement$bias_rank[temp_replacement$condition_id == condition_id] <- rank(abs(temp_replacement$bias[temp_replacement$condition_id == condition_id]), ties.method = "min")
      temp_conditional$rmse_rank[temp_conditional$condition_id == condition_id] <- rank(temp_conditional$rmse[temp_conditional$condition_id == condition_id], ties.method = "min")
      temp_replacement$rmse_rank[temp_replacement$condition_id == condition_id] <- rank(temp_replacement$rmse[temp_replacement$condition_id == condition_id], ties.method = "min")
    }
  }
  
  results_conditional_list[[dgm_name]] <- temp_conditional
  results_replacement_list[[dgm_name]] <- temp_replacement
}

# clean up 
rm("temp_conditional", "temp_replacement", "dgm_name")

results_conditional <- do.call(rbind, results_conditional_list)
results_replacement <- do.call(rbind, results_replacement_list)
method_labels       <- unique(results_conditional$label)
```

```{r, include = FALSE}
# compute average performance
tables_conditional <- make_table_summary(results_conditional, common_scale = common_scale)
tables_replacement <- make_table_summary(results_replacement, common_scale = common_scale)

# add ranks
rankings_conditional <- make_rank_summary(tables_conditional)
rankings_replacement <- make_rank_summary(tables_replacement)
```

### Average Performance {.tabset .tabset-fade .tabset-pills}

```{r, include = FALSE}
this_rankings_conditional <- rankings_conditional
this_tables_conditional   <- tables_conditional
this_rankings_replacement <- rankings_replacement
this_tables_replacement   <- tables_replacement
```
```{r, child = child_path("_results-tabs-tables.Rmd")}
```


### By-Condition Performance (Conditional on Method Convergence) {.tabset .tabset-fade .tabset-pills}

The results below are conditional on method convergence. Note that the methods might differ in convergence rate and are therefore not necessarily compared on the same data sets.

```{r, include = FALSE}
this_results <- results_conditional
```
```{r, child = child_path("_results-tabs-figures.Rmd")}
```


### By-Condition Performance (Replacement in Case of Non-Convergence) {.tabset .tabset-fade .tabset-pills}

The results below incorporate method replacement to handle non-convergence. If a method fails to converge, its results are replaced with the results from a simpler method (e.g., random-effects meta-analysis). This emulates what a data analyst may do in practice in case a method does not converge. However, note that these results do not correspond to "pure" method performance as they might combine multiple different methods. See TODO for details of the method replacement specification.

```{r, include = FALSE}
this_results <- results_replacement
```
```{r, child = child_path("_results-tabs-figures.Rmd")}
```
